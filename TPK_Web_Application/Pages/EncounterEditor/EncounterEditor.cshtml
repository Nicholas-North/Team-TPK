@page
@model EncounterEditorModel
@{
}

<body>
    <div class="Formatting">
        <div class="frame">
            <div class="grid-controls">
                <button id="increase-grid" class="btn btn-sm btn-secondary">+</button>
                <button id="decrease-grid" class="btn btn-sm btn-secondary">-</button>
                <span id="grid-size-display" class="ml-2">50x50</span>
                <button id="toggle-coords" class="btn btn-sm btn-secondary ml-2">Toggle Coordinates</button>
            </div>
            <div class="grid-container" id="grid-container">
                <div class="grid" id="grid">
                    <!-- Grid items will be dynamically created -->
                </div>
            </div>
        </div>
        <div class="col-md-4" id="EncounterVault">
            <h2>Encounter Vault</h2>
            <div class="sticky-top bg-white p-3 mb-3">
                <button type="button" class="list-group-item list-group-item-action mb-3" data-toggle="modal" data-target="#EncounterEditorModal">Create New Encounter</button>
            </div>
            <ul class="list-group" id="encounter-list">
                <!-- Encounters will be dynamically loaded here -->
            </ul>
        </div>
        <div class="col-md-4 d-none" id="CharacterVault">
            <h2>Character Vault</h2>
            <ul class="list-group" id="character-list">
                <!-- Characters will be dynamically loaded here -->
            </ul>
        </div>
    </div>

    <div class="Manip-Buttons">
        <form method="post" asp-page-handler="SaveEncounter" id="SaveEncounterForm" class="requires-encounter d-none">
            <input type="hidden" asp-for="SelectedEncounter.encounterID" id="SelectedEncounterId" />
            <input type="hidden" asp-for="SelectedCharacter.characterID" />
            <input type="hidden" id="gridData" name="gridData" />
            <button type="button" class="btn btn-secondary btn-sm edit-button" onclick="toggleEdit(this)" id="EditButton">Edit</button>
            <button type="button" class="btn btn-secondary btn-sm close-button d-none" onclick="toggleEdit(this)" id="CloseButton">Close</button>
            <button type="submit" class="btn btn-primary btn-sm save-button d-none" id="SaveButton">Save</button>
        </form>
        <form method="post" asp-page-handler="RunEncounter" class="requires-encounter d-none">
            <input type="hidden" asp-for="SelectedEncounter.encounterID" />
            <button type="submit" class="btn btn-primary">Run Encounter</button>
        </form>
    </div>

    <div class="modal fade" id="EncounterEditorModal" tabindex="-1" role="dialog" aria-labelledby="Encounter Editor" aria-hidden="true">
        <div class="modal-dialog" role="document">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Encounter Editor</h5>
                    <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                        <span aria-hidden="true">&times;</span>
                    </button>
                </div>
                <div class="modal-body">
                    <form method="post" asp-page-handler="CreateEncounter">
                        <input type="hidden" id="selectedEncounterId" name="selectedEncounterId" value="@Model.SelectedEncounter.encounterID" />
                        <label for="NameInput">Map X dimensions: </label>
                        <input type="number" asp-for="XInput" class="form-control" id="XInput" name="XInput" min="5" max="100" />
                        <label for="AncestryInput">Map Y dimensions: </label>
                        <input type="number" asp-for="YInput" class="form-control" id="YInput" name="YInput" min="5" max="100" />
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-dismiss="modal">Close</button>
                            <button type="submit" class="btn btn-primary">Save changes</button>
                        </div>
                    </form>
                </div>
            </div>
        </div>
    </div>
    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>

    <script>
        // Global variables
        let currentlyHighightedElement = null;
        let selectedEncounter = null;
        let gridSizeX = 50;
        let gridSizeY = 50;
        let showCoordinates = false;
        let draggedToken = null;
        let draggedTokenOriginalCell = null;
        const characterMap = new Map(); // Stores character data by ID

        // Helper function to get initials from name
        function getInitials(name) {
            return name.split(' ')
                .map(word => word[0])
                .join('')
                .toUpperCase()
                .substring(0, 2);
        }

        // Initialize grid on page load
        function initializeGrid() {
            createGrid(gridSizeX, gridSizeY);
            setupGridControls();
        }

        // Create grid with dynamic dimensions
        function createGrid(xSize, ySize) {
            const grid = document.getElementById('grid');
            grid.innerHTML = '';

            gridSizeX = xSize;
            gridSizeY = ySize;
            document.getElementById('grid-size-display').textContent = `${xSize}x${ySize}`;

            grid.style.gridTemplateColumns = `repeat(${xSize}, 50px)`;
            grid.style.gridTemplateRows = `repeat(${ySize}, 50px)`;

            for (let i = 0; i < xSize * ySize; i++) {
                const gridItem = document.createElement('div');
                gridItem.className = 'grid-item';
                gridItem.id = `grid-item-${i}`;

                if (showCoordinates) {
                    const x = i % xSize;
                    const y = Math.floor(i / xSize);
                    gridItem.setAttribute('title', `(${x}, ${y})`);
                }

                grid.appendChild(gridItem);
            }

            enableGridDropping();
            enableGridItemDeletion();
        }

        // Setup grid controls
        function setupGridControls() {
            document.getElementById('increase-grid').addEventListener('click', () => {
                createGrid(gridSizeX + 5, gridSizeY + 5);
            });

            document.getElementById('decrease-grid').addEventListener('click', () => {
                if (gridSizeX > 5 && gridSizeY > 5) {
                    createGrid(gridSizeX - 5, gridSizeY - 5);
                }
            });

            document.getElementById('toggle-coords').addEventListener('click', () => {
                showCoordinates = !showCoordinates;
                const gridItems = document.querySelectorAll('.grid-item');
                gridItems.forEach((item, index) => {
                    if (showCoordinates) {
                        const x = index % gridSizeX;
                        const y = Math.floor(index / gridSizeX);
                        item.setAttribute('title', `(${x}, ${y})`);
                    } else {
                        item.removeAttribute('title');
                    }
                });
            });
        }

        // Fetch and display encounters
        function loadEncounters() {
            fetch('/api/EncounterAPI/GetEncounters')
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    const encounterList = document.getElementById('encounter-list');
                    encounterList.innerHTML = '';
                    data.forEach(encounter => {
                        const listItem = document.createElement('li');
                        listItem.className = 'list-group-item';
                        listItem.textContent = `Encounter ID: ${encounter.encounterID}`;

                        listItem.onclick = () => {
                            selectEncounter(encounter.encounterID);
                            highlightSelected(listItem);
                        }
                        encounterList.appendChild(listItem);
                    });
                })
                .catch(error => console.error('Error fetching encounters:', error));
        }

        function loadCharacters() {
            fetch('/api/EncounterAPI/GetCharacters')
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    const characterList = document.getElementById('character-list');
                    characterList.innerHTML = '';
                    
                    // Clear and rebuild character map
                    characterMap.clear();
                    data.forEach(character => {
                        characterMap.set(character.characterID, character);
                        
                        const listItem = document.createElement('li');
                        listItem.className = 'list-group-item character-item';
                        listItem.textContent = character.characterName;
                        listItem.setAttribute('data-character-id', character.characterID);
                        listItem.setAttribute('data-character-name', character.characterName);

                        // Add colored token preview with initials
                        const tokenPreview = document.createElement('span');
                        tokenPreview.className = 'token-preview';
                        tokenPreview.style.backgroundColor = getRandomColor();
                        tokenPreview.textContent = getInitials(character.characterName);
                        listItem.prepend(tokenPreview);

                        listItem.onclick = () => {
                            selectCharacter(character.characterID);
                            highlightSelected(listItem);
                        }
                        characterList.appendChild(listItem);
                    });

                    makeCharactersDraggable();
                })
                .catch(error => console.error('Error fetching characters:', error));
        }

        // Select an encounter and display its characters
        function selectEncounter(encounterId) {
            toggleElementsVisibility();
            document.getElementById('SelectedEncounterId').value = encounterId;
            selectedEncounter = encounterId;

            fetch(`/api/EncounterAPI/GetPositions/${encounterId}`)
                .then(response => response.json())
                .then(data => {
                    // Clear the grid
                    const gridItems = document.querySelectorAll('.grid-item');
                    gridItems.forEach(item => {
                        item.innerHTML = '';
                        item.style.backgroundColor = '';
                    });

                    // Place characters on grid
                    data.forEach(character => {
                        if (character.xloc !== undefined && character.yloc !== undefined) {
                            const gridIndex = character.yloc * gridSizeX + character.xloc;
                            const gridItem = document.getElementById(`grid-item-${gridIndex}`);
                            if (gridItem && characterMap.has(character.characterID)) {
                                const charData = characterMap.get(character.characterID);
                                const token = document.createElement('div');
                                token.className = 'character-token';
                                token.textContent = getInitials(charData.characterName);
                                token.style.backgroundColor = getRandomColor();
                                token.setAttribute('data-character-id', character.characterID);
                                token.setAttribute('draggable', true);
                                gridItem.appendChild(token);
                            }
                        }
                    });
                })
                .catch(error => console.error('Error fetching characters:', error));
        }

        function selectCharacter(characterId) {
            console.log(`Selected Character ID: ${characterId}`);
        }

        function toggleEdit(button) {
            const encounterVault = document.getElementById('EncounterVault');
            const characterVault = document.getElementById('CharacterVault');
            const editButton = document.getElementById('EditButton');
            const closeButton = document.getElementById('CloseButton');
            const saveButton = document.getElementById('SaveButton');

            encounterVault.classList.toggle('d-none');
            characterVault.classList.toggle('d-none');
            editButton.classList.toggle('d-none');
            closeButton.classList.toggle('d-none');
            saveButton.classList.toggle('d-none');
        }

        function toggleElementsVisibility() {
            const elementsToToggle = document.querySelectorAll('.requires-encounter');
            elementsToToggle.forEach(element => {
                if (selectedEncounter == null) {
                    element.classList.remove('d-none');
                }
            });
        }

        function makeCharactersDraggable() {
            const characterItems = document.querySelectorAll('.character-item');
            characterItems.forEach(item => {
                item.setAttribute('draggable', true);

                item.addEventListener('dragstart', (e) => {
                    e.dataTransfer.setData('text/plain', JSON.stringify({
                        characterId: item.dataset.characterId,
                        characterName: item.dataset.characterName,
                        color: item.querySelector('.token-preview').style.backgroundColor
                    }));
                    item.classList.add('dragging');
                });

                item.addEventListener('dragend', () => {
                    item.classList.remove('dragging');
                });
            });
        }

        function enableGridDropping() {
            const gridItems = document.querySelectorAll('.grid-item');

            gridItems.forEach(item => {
                // Handle drag start for tokens already on the grid
                item.addEventListener('dragstart', (e) => {
                    if (e.target.classList.contains('character-token')) {
                        draggedToken = e.target;
                        draggedTokenOriginalCell = item;
                        
                        const characterId = e.target.dataset.characterId;
                        const charData = characterMap.get(characterId);
                        
                        e.dataTransfer.setData('text/plain', JSON.stringify({
                            characterId: characterId,
                            characterName: charData.characterName,
                            color: e.target.style.backgroundColor
                        }));
                        
                        e.target.classList.add('dragging');
                        setTimeout(() => e.target.classList.add('invisible'), 0);
                    }
                });

                // Handle drag end for tokens
                item.addEventListener('dragend', (e) => {
                    if (e.target.classList.contains('character-token')) {
                        e.target.classList.remove('dragging', 'invisible');
                        draggedToken = null;
                        draggedTokenOriginalCell = null;
                    }
                });

                // Handle drop zone functionality
                item.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    if (!item.querySelector('.character-token')) {
                        item.classList.add('drop-target');
                    }
                });

                item.addEventListener('dragleave', () => {
                    item.classList.remove('drop-target');
                });

                item.addEventListener('drop', (e) => {
                    e.preventDefault();
                    item.classList.remove('drop-target');

                    try {
                        const data = JSON.parse(e.dataTransfer.getData('text/plain'));
                        if (data.characterId && data.characterName) {
                            // Remove the original token if it exists and we're moving to a new cell
                            if (draggedTokenOriginalCell && draggedTokenOriginalCell !== item) {
                                draggedTokenOriginalCell.innerHTML = '';
                            }

                            // Only create token if the target cell is empty
                            if (!item.querySelector('.character-token')) {
                                const token = document.createElement('div');
                                token.className = 'character-token';
                                token.textContent = getInitials(data.characterName);
                                token.style.backgroundColor = data.color || getRandomColor();
                                token.setAttribute('data-character-id', data.characterId);
                                token.setAttribute('draggable', true);
                                item.appendChild(token);
                            }
                        }
                    } catch (error) {
                        console.error('Error processing drop:', error);
                    }
                });
            });
        }

        function enableGridItemDeletion() {
            const gridItems = document.querySelectorAll('.grid-item');
            let selectedGridItem = null;

            gridItems.forEach(item => {
                item.addEventListener('click', (e) => {
                    if (e.target === item) { // Only select if clicking the grid item itself, not a token
                        if (selectedGridItem) {
                            selectedGridItem.classList.remove('selected');
                        }
                        selectedGridItem = item;
                        item.classList.add('selected');
                    }
                });
            });

            document.addEventListener('keydown', (e) => {
                if (e.key === 'Delete' && selectedGridItem) {
                    selectedGridItem.innerHTML = '';
                    selectedGridItem.classList.remove('selected');
                    selectedGridItem = null;
                }
            });
        }

        function collectGridData() {
            const gridItems = document.querySelectorAll('.grid-item');
            const gridData = [];

            gridItems.forEach((item, index) => {
                if (item.firstChild && item.firstChild.classList.contains('character-token')) {
                    const x = index % gridSizeX;
                    const y = Math.floor(index / gridSizeX);
                    const characterId = item.firstChild.dataset.characterId;
                    gridData.push({ x, y, characterId });
                }
            });

            document.getElementById('gridData').value = JSON.stringify(gridData);
            console.log('Grid Data:', gridData);
        }

        function highlightSelected(element) {
            if (currentlyHighightedElement) {
                currentlyHighightedElement.classList.remove('highlight-selected');
            }
            element.classList.add('highlight-selected');
            currentlyHighightedElement = element;
        }

        function getRandomColor() {
            const colors = ['#FFADAD', '#FFD6A5', '#FDFFB6', '#CAFFBF', '#9BF6FF', '#A0C4FF', '#BDB2FF', '#FFC6FF'];
            return colors[Math.floor(Math.random() * colors.length)];
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', () => {
            initializeGrid();
            loadEncounters();
            loadCharacters();

            document.getElementById('SaveEncounterForm').addEventListener('submit', (e) => {
                e.preventDefault();
                collectGridData();
                e.target.submit();
            });

            // Zoom and pan functionality
            const gridContainer = document.getElementById('grid-container');
            let scale = 1;
            let isPanning = false;
            let startX, startY;
            let translateX = 0, translateY = 0;

            gridContainer.addEventListener('wheel', (e) => {
                e.preventDefault();
                const zoomSpeed = 0.1;
                const delta = e.deltaY < 0 ? zoomSpeed : -zoomSpeed;
                const newScale = Math.max(0.1, Math.min(3, scale + delta));

                const mouseX = e.clientX;
                const mouseY = e.clientY;
                const rect = gridContainer.getBoundingClientRect();
                const offsetX = mouseX - rect.left;
                const offsetY = mouseY - rect.top;

                const gridX = (offsetX - translateX) / scale;
                const gridY = (offsetY - translateY) / scale;

                scale = newScale;
                translateX = offsetX - gridX * scale;
                translateY = offsetY - gridY * scale;

                gridContainer.style.transform = `scale(${scale}) translate(${translateX}px, ${translateY}px)`;
            });

            gridContainer.addEventListener('mousedown', (e) => {
                if (e.button === 0) {
                    isPanning = true;
                    startX = e.clientX - translateX;
                    startY = e.clientY - translateY;
                    gridContainer.style.cursor = 'grabbing';
                }
            });

            document.addEventListener('mousemove', (e) => {
                if (!isPanning) return;
                translateX = e.clientX - startX;
                translateY = e.clientY - startY;
                gridContainer.style.transform = `scale(${scale}) translate(${translateX}px, ${translateY}px)`;
            });

            document.addEventListener('mouseup', () => {
                isPanning = false;
                gridContainer.style.cursor = 'grab';
            });
        });
    </script>

    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            padding: 20px;
        }

        .Formatting {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }

        .frame {
            width: 100%;
            max-width: 800px;
            height: 80vh;
            overflow: hidden;
            border: 2px solid #343a40;
            border-radius: 5px;
            position: relative;
            background-color: white;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .grid-controls {
            padding: 10px;
            background-color: #343a40;
            color: white;
            display: flex;
            align-items: center;
        }

        .grid-container {
            position: absolute;
            top: 50px;
            left: 0;
            transform-origin: 0 0;
            will-change: transform;
        }

        .grid {
            display: grid;
            gap: 0;
            background-color: #f0f0f0;
        }

        .grid-item {
            border: 1px solid #ddd;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: white;
            transition: background-color 0.2s;
        }

        .grid-item:nth-child(odd) {
            background-color: #f8f9fa;
        }

        .grid-item.selected {
            outline: 2px solid #dc3545;
        }

        .grid-item.drop-target {
            background-color: #e2f0fd !important;
        }

        .character-token {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: bold;
            cursor: move;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .character-token.invisible {
            opacity: 0.2;
            background-color: #ccc !important;
        }

        .character-token.dragging {
            transform: scale(1.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
            z-index: 100;
        }

        .token-preview {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 10px;
            color: white;
            font-size: 10px;
            text-align: center;
            line-height: 20px;
        }

        .col-md-4 {
            flex: 0 0 300px;
            background-color: white;
            border-radius: 5px;
            padding: 15px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            height: fit-content;
        }

        .list-group {
            max-height: 70vh;
            overflow-y: auto;
        }

        .list-group-item {
            cursor: pointer;
            display: flex;
            align-items: center;
            transition: background-color 0.2s;
        }

        .list-group-item:hover {
            background-color: #f8f9fa;
        }

        .highlight-selected {
            background-color: #e2f0fd !important;
            border-left: 3px solid #007bff;
        }

        .dragging {
            opacity: 0.5;
        }

        .Manip-Buttons {
            margin-top: 20px;
            display: flex;
            gap: 10px;
        }

        .btn {
            transition: all 0.2s;
        }

        @@media (max-width: 768px) {
            .Formatting {
                flex-direction: column;
            }
            .frame {
                height: 60vh;
            }
            .col-md-4 {
                width: 100%;
            }
            .grid-item {
                width: 30px;
                height: 30px;
            }
            .character-token {
                width: 25px;
                height: 25px;
                font-size: 10px;
            }
        }
    </style>
</body>